# 什么是悲观锁？

悲观锁是一种同步机制，它假设在对共享资源进行操作时，总会发生最坏的情况（例如，数据被其他线程修改）。因此，每次在获取共享资源进行操作时，都会先上锁。这样，其他线程如果想要获取这个资源，就会被阻塞，直到锁被释放。换句话说，悲观锁每次只允许一个线程使用共享资源，其他线程则会被阻塞。

在Java中，synchronized和ReentrantLock等独占锁就是悲观锁的实现。例如：

```java
public void performSynchronisedTask() {
    synchronized (this) {
        // 需要同步的操作
    }
}

private Lock lock = new ReentrantLock();
lock.lock();
try {
   // 需要同步的操作
} finally {
    lock.unlock();
}
```

在高并发的场景下，悲观锁可能会导致激烈的锁竞争，从而引发线程阻塞。大量的阻塞线程会增加系统的上下文切换，从而增加系统的性能开销。此外，悲观锁还可能会导致死锁，影响代码的正常运行。

# 什么是乐观锁？

乐观锁是一种并发控制的策略，它假设多个线程在操作数据时，冲突的情况较少，因此在访问共享资源时不会立即加锁，而是在数据提交时才会检查是否有其他线程修改了这段数据。如果发现有冲突，就会进行相应的处理，例如重试这次操作或者抛出异常。


乐观锁适用于读多写少的并发场景，可以避免因为频繁的加锁和解锁操作导致的性能开销。但是，如果冲突发生的频率较高，乐观锁就需要频繁地进行回滚和重试，可能会导致性能下降。

# 该如何选择乐观锁或悲观锁？

这取决于应用场景和数据的具体访问模式。

1. 如果应用的写操作比较多，或者说并发竞争比较激烈，那么悲观锁可能是更好的选择。因为在这种情况下，冲突发生的概率比较高，使用悲观锁可以避免频繁的失败和重试，从而提高性能。悲观锁的开销是固定的，不会因为冲突的频率增加而增加。

2. 如果应用的读操作比较多，写操作比较少，或者说并发竞争不是很激烈，那么乐观锁可能是更好的选择。因为在这种情况下，冲突发生的概率比较低，使用乐观锁可以避免不必要的加锁操作，从而提高性能。但是，如果冲突发生的频率较高，乐观锁就需要频繁地进行回滚和重试，可能会导致性能下降。

# 如何实现乐观锁？

乐观锁的实现主要有两种方式：版本号机制和CAS算法。

1. 版本号机制：
   这是一种常见的乐观锁实现方式。每个数据项都有一个版本号，每次读取数据时，都会读取出数据的版本号。当线程尝试更新数据时，会检查当前数据的版本号是否和自己读取出来的版本号一致。如果一致，说明这段时间内没有其他线程修改过数据，更新操作可以成功，并且将版本号加一。如果不一致，说明其他线程已经修改过数据，当前线程的更新操作失败。

   在Java中，可以通过AtomicInteger类或者数据库的版本字段来实现。例如：

   ```java
   private AtomicInteger version = new AtomicInteger(0);

   public void update(Data data) {
       int currentVersion = version.get();
       // 修改数据
       if (!version.compareAndSet(currentVersion, currentVersion + 1)) {
           // 如果版本号已经被其他线程修改，重新读取数据
       }
   }
   ```

2. CAS算法：
   CAS（Compare And Swap）算法是一种无锁算法。CAS算法包含三个操作数：内存值V、预期值A、新值B。当内存值V等于预期值A时，将内存值修改为B并返回true，否则什么都不做并返回false。CAS算法通过硬件指令保证了操作的原子性。

   在Java中，可以通过AtomicInteger类的compareAndSet方法来实现CAS算法。例如：

   ```java
   private AtomicInteger value = new AtomicInteger(0);

   public void update(int newValue) {
       int current;
       do {
           current = value.get();
       } while (!value.compareAndSet(current, newValue));
   }
   ```

这两种方式都可以实现乐观锁，选择哪种方式取决于具体的应用场景和需求。

# 乐观锁存在哪些问题？

- **ABA问题**：

这是使用CAS算法实现乐观锁时可能会遇到的问题。如果一个值原来是A，被一个线程改为B，然后又被改回A，那么其他使用CAS算法的线程会认为这个值没有被改变，但实际上这个值已经被其他线程改变过两次。这种问题可以通过引入版本号来解决。

- **性能问题**：

乐观锁最大的问题就是冲突的处理。在高并发的场景下，如果有多个线程同时对同一条数据进行更新，可能会导致大量的更新操作因为版本号不匹配而失败。这种情况下，线程需要重新读取数据并尝试更新，这会增加系统的开销。
